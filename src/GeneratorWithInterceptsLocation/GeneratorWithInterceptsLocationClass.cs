using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;

namespace GeneratorWithInterceptsLocation;

[Generator(LanguageNames.CSharp)]
public sealed class GeneratorWithInterceptsLocationClass : IIncrementalGenerator
{
    private record MethodInformation(ITypeSymbol TypeSymbol, string Path, int Line, int Column);

    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(GeneratorWithInterceptsLocationClass).Assembly.GetName().Name}"", ""{typeof(GeneratorWithInterceptsLocationClass).Assembly.GetName().Version}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
        context.RegisterPostInitializationOutput(CreateBaseClass);

        var methodUsages = context.SyntaxProvider
        .CreateSyntaxProvider(
                predicate: IsInvocationExpression,
                transform: TransformMethodInformation
                )
            .Where(symbol => symbol is not null)
            .Collect();

        context.RegisterSourceOutput(methodUsages, CreateSourceCode);
    }

    private static void CreateBaseClass(IncrementalGeneratorPostInitializationContext context)
    {
        var sourceCode = $$"""
            // <auto-generated/>
            #nullable enable

            using System;
                            
            namespace CodeGenerated;

            {{generatedCodeAttribute}}
            internal static class Helper
            {
                internal static string[] GetProperties<T>() where T : class => [];
            }
            """;

        var fileName = "CodeGenerated.Helper.g.cs";
        context.AddSource(fileName, sourceCode);
    }

    private static bool IsInvocationExpression(SyntaxNode node, CancellationToken _) => node is InvocationExpressionSyntax;

    private static MethodInformation? TransformMethodInformation(GeneratorSyntaxContext ctx, CancellationToken _)
    {
        if (ctx.Node is not InvocationExpressionSyntax invocation) return null;

        var semanticModel = ctx.SemanticModel;
        var expression = invocation.Expression;

        if (semanticModel.GetSymbolInfo(expression).Symbol is not IMethodSymbol { Name: var name } methodSymbol
    || name != "GetProperties") return null;

        var containingType = methodSymbol.ContainingType;
        if (!SymbolEqualityComparer.Default.Equals(containingType, semanticModel.Compilation.GetTypeByMetadataName("CodeGenerated.Helper"))) return null;

        if (expression is not MemberAccessExpressionSyntax memberAccess) return null;

        var typeSymbol = methodSymbol.TypeArguments.First();
        var methodNameToken = memberAccess.Name.Identifier;
        var location = methodNameToken.GetLocation().GetLineSpan();
        var path = location.Path;
        var line = location.StartLinePosition.Line + 1;
        var column = location.StartLinePosition.Character + 1;

        return new MethodInformation(typeSymbol, path, line, column);
    }

    private static void CreateSourceCode(SourceProductionContext ctx, ImmutableArray<MethodInformation?> methodSymbols)
    {
        //if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
        var coll = methodSymbols.GroupBy(
            t => t!.TypeSymbol,
            t => t!,
            SymbolEqualityComparer.Default
        ).Select(group => new
        {
            ObjClass = (INamedTypeSymbol)group.Key,
            LocationInformations = group.Select(t => new
            {
                t.Path,
                t.Line,
                t.Column
            })
        });

        using StringWriter writer = new(CultureInfo.InvariantCulture);
        using IndentedTextWriter tx = new(writer);
        void w(string txt = "") => tx.WriteLine(txt);

        w("// <auto-generated/>");
        w("#nullable enable");
        w();
        w("using System;");
        w("using System.Runtime.CompilerServices;");
        w();
        w("namespace System.Runtime.CompilerServices");
        w("{");
        tx.Indent++;
        w(generatedCodeAttribute);
        w("[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
        w("#pragma warning disable CS9113");
        w("file sealed class InterceptsLocationAttribute : Attribute");
        w("{");
        tx.Indent++;
        w("internal InterceptsLocationAttribute(string filePath, int line, int column) {}");
        tx.Indent--;
        w("}");
        w("#pragma warning restore CS9113");
        tx.Indent--;
        w("}");
        w();

        w("namespace CodeGenerated");
        w("{");
        tx.Indent++;
        w(generatedCodeAttribute);
        w("file static class Interceptors");
        w("{");
        tx.Indent++;

        foreach (var item in coll)
        {
            foreach (var symbol in item.LocationInformations)
            {
                w("[InterceptsLocation(");
                tx.Indent++;
                w($"filePath: @\"{symbol.Path}\",");
                w($"line: {symbol.Line},");
                w($"column: {symbol.Column})]");
                tx.Indent--;
            }

            var className = item.ObjClass.ToDisplayString().Replace(".", string.Empty);
            w($"internal static string[] GetProperties{className}<T>() where T : class");
            w("{");
            tx.Indent++;
            w("return [");
            tx.Indent++;

            var properties = item.ObjClass.GetMembers().OfType<IPropertySymbol>();
            foreach (var property in properties)
            {
                w($"""
                    "{property.Name}",
                    """);
            }

            w("];");
            tx.Indent--;
            tx.Indent--;
            w("}");
            w();
        }

        tx.Indent--;
        w("}");
        tx.Indent--;
        w("}");

        Debug.Assert(tx.Indent == 0);

        var fileName = "CodeGenerated.Helper.Interceptor.g.cs";
        ctx.AddSource(fileName, writer.ToString());
    }
}