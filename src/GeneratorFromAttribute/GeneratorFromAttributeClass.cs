using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;

namespace GeneratorFromAttribute;

[Generator(LanguageNames.CSharp)]
public class GeneratorFromAttributeClass : IIncrementalGenerator
{
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(GeneratorFromAttributeClass).Assembly.GetName().Name}"", ""{typeof(GeneratorFromAttributeClass).Assembly.GetName().Version}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //if (!Debugger.IsAttached) Debugger.Launch();
        GenerateFixedClasses(context);

        IncrementalValuesProvider<(string TypeName, Accessibility ClassAccessibility, string? Namespaces, MasterType masterType)> provider =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "GeneratorFromAttributeExample.GeneratedAttribute",
                predicate: FilterClass,
                transform: CreateObjCollection);

        context.RegisterSourceOutput(provider, static void (SourceProductionContext context, (string TypeName, Accessibility ClassAccessibility, string? Namespaces, MasterType MasterType) info) =>
        {
            //if (!Debugger.IsAttached) Debugger.Launch();
            if (!info.MasterType.IsPartial || !info.MasterType.IsStatic)
            {
                Helper.ReportClassNotSupportedDiagnostic(context, info.MasterType.ClassName);
                return;
            }

            using StringWriter writer = new(CultureInfo.InvariantCulture);
            using IndentedTextWriter tx = new(writer);

            tx.WriteLine("// <auto-generated/>");
            tx.WriteLine("#nullable enable");
            tx.WriteLine();
            tx.WriteLine("using System.Globalization;");
            tx.WriteLine("using GeneratorFromAttributeExample;");

            if (!string.IsNullOrEmpty(info.Namespaces))
            {
                tx.WriteLine($"namespace {info.Namespaces}");
                tx.WriteLine("{");
                tx.Indent++;
            }

            tx.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{typeof(GeneratorFromAttributeClass).Assembly.GetName().Name}\", \"{typeof(GeneratorFromAttributeClass).Assembly.GetName().Version}\")]");
            tx.WriteLine($"{SyntaxFacts.GetText(info.ClassAccessibility)} static partial class {info.TypeName}");
            tx.WriteLine("{");
            tx.Indent++;

            foreach (var subType in info.MasterType.SubTypes)
            {
                var ns = string.IsNullOrEmpty(subType.Namespace) ? string.Empty : subType.Namespace! + ".";
                tx.WriteLine($"{SyntaxFacts.GetText(info.ClassAccessibility)} static bool SetProperty{subType.Classname}({ns}{subType.Classname} obj, ReadOnlySpan<char> propertyName, string? value) =>");
                tx.Indent++;
                tx.WriteLine($"propertyName switch");
                tx.WriteLine("{");
                tx.Indent++;
                InsertPropertiesInSwitch(context, tx, subType);
                tx.WriteLine("_ => false");
                tx.Indent--;
                tx.WriteLine("};");
                tx.Indent--;
                tx.WriteLine();
            }

            tx.Indent--;
            tx.WriteLine("}");
            if (!string.IsNullOrEmpty(info.Namespaces))
            {
                tx.Indent--;
                tx.WriteLine("}");
            }

            Debug.Assert(tx.Indent == 0);
            context.AddSource($"{info.TypeName}.g.cs", writer.ToString());
        });
    }

    private static void GenerateFixedClasses(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static void (IncrementalGeneratorPostInitializationContext context) =>
        {
            {
                const string hintName = "GeneratorFromAttributeExample.GeneratedAttribute.g.cs";
                //language=c#
                string source = $$"""
                // <auto-generated/>
                #nullable enable
                using System;
                namespace GeneratorFromAttributeExample;

                {{generatedCodeAttribute}}
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
                public sealed class GeneratedAttribute : global::System.Attribute
                {
                    public Type Type { get; }
                    public GeneratorNotTypeRecognized GeneratorNotTypeRecognized { get; }

                    public GeneratedAttribute(Type type, GeneratorNotTypeRecognized generatorNotTypeRecognized = GeneratorNotTypeRecognized.CompilationError)
                    {
                        Type = type;
                        GeneratorNotTypeRecognized = generatorNotTypeRecognized;
                    }
                }

                public enum GeneratorNotTypeRecognized : int { Skip = 0, ThrowException = 1, CompilationError = 2 }
                """;

                context.AddSource(hintName, source);
            }

            {
                const string hintName = "GeneratorFromAttributeExample.HelperFunction.g.cs";
                //language=c#
                string source = $$"""
                // <auto-generated/>
                #nullable enable
                using System.Globalization;
                using System.Numerics;
                using System.Runtime.CompilerServices;

                namespace GeneratorFromAttributeExample;

                {{generatedCodeAttribute}}
                public static class ConversionHelper
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static bool ParseDateTime(string s, Func<DateTime, bool> setValue) =>
                        (DateTimeNullableConvert(s) is not { } value) ? false : setValue(value);

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static bool ParseDateTimeNullable(string? s, Func<DateTime?,bool> setValue) =>
                        (s is null) ? setValue(null) : ParseDateTime(s, (x) => setValue(x!));

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static bool ParseNumber<T>(string s, Func<T, bool> setValue) where T : struct, INumberBase<T> =>
                        (NumberNullableConvert<T>(s) is not { } value) ? false : setValue(value);

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static bool ParseNumberNullable<T>(string? s, Func<T?, bool> setValue) where T : struct, INumberBase<T> =>
                        (s is null) ? setValue(null) : ParseNumber<T>(s, (x) => setValue(x!));

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static bool ParseString(string s, Func<string, bool> setValue) =>
                        setValue(s);

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static bool ParseStringNullable(string? s, Func<string?, bool> setValue) =>
                        (s is null) ? setValue(null) : setValue(s);

                    [MethodImpl(MethodImplOptions.AggressiveInlining)] 
                    public static DateTime? DateTimeNullableConvert(string? date) => DateTime.TryParse(date, out var dt) ? dt : null;

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static T? NumberNullableConvert<T>(string? number) where T : struct, INumberBase<T> => T.TryParse(number, NumberStyles.Any, CultureInfo.InvariantCulture, out var t) ? t : null;
                }
                """;

                context.AddSource(hintName, source);
            }
        });
    }

    private static bool FilterClass(SyntaxNode node, CancellationToken cancellationToken) =>
        node is ClassDeclarationSyntax;

    private static (string TypeName, Accessibility ClassAccessibility, string? Namespaces, MasterType masterType) CreateObjCollection(GeneratorAttributeSyntaxContext context, CancellationToken _)
    {
        //if (!Debugger.IsAttached) Debugger.Launch();
        var symbol = (INamedTypeSymbol)context.TargetSymbol;
        var className = symbol.Name;

        var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;
        var isPartial = classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        var isStatic = classDeclarationSyntax.Modifiers.Any(SyntaxKind.StaticKeyword);

        var namespacesClass = string.IsNullOrEmpty(symbol.ContainingNamespace.Name) ? null : symbol.ContainingNamespace.ToDisplayString();
        MasterType masterType = new(className, isPartial, isStatic);
        List<string> classNames = [];

        foreach (var attributeData in context.Attributes)
        {
            var typeArgument0 = attributeData.ConstructorArguments[0];
            if (typeArgument0.Value is not ITypeSymbol typeSymbol) continue;
            if (classNames.Contains(typeSymbol.Name)) continue;
            classNames.Add(typeSymbol.Name);

            var generatorNotTypeRecognized = GeneratorNotTypeRecognized.CompilationError;
            if (attributeData.ConstructorArguments.Length == 2)
            {
                var typeArgument1 = attributeData.ConstructorArguments[1];
                if (typeArgument1.Kind == TypedConstantKind.Enum)
                {
                    generatorNotTypeRecognized = (GeneratorNotTypeRecognized)int.Parse(typeArgument1.Value!.ToString());
                }
            }

            var ns = string.IsNullOrEmpty(typeSymbol.ContainingNamespace.Name) ? null : typeSymbol.ContainingNamespace.ToDisplayString();
            var properties = typeSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(t => new SubProperty(t.Name, t.Type)).ToList();

            masterType.SubTypes.Add(new SubTypeClass(
                typeSymbol.Name,
                ns,
                generatorNotTypeRecognized,
                properties)
            );
        }

        return (className, symbol.DeclaredAccessibility, namespacesClass, masterType);
    }

    private static void InsertPropertiesInSwitch(SourceProductionContext context, IndentedTextWriter tx, SubTypeClass subType)
    {
        foreach (var property in subType.Properties)
        {
            tx.Write($"\"{property.Name}\" => ");

            var clrType = Helper.GetClrTypeName(property.Type);
            if (clrType.TypeClr == Helper.TypeClr.Unknown)
            {
                switch (subType.GeneratorNotTypeRecognized)
                {
                    case GeneratorNotTypeRecognized.Skip: break;
                    case GeneratorNotTypeRecognized.ThrowException: tx.WriteLine($"throw new ArgumentException(\"The type '{property.Type.ToDisplayString()}' in property '{property.Name}' is not supported\"),"); return;
                    case GeneratorNotTypeRecognized.CompilationError: { Helper.ReportTypeNotSupportedDiagnostic(context, property.Name, property.Type.ToDisplayString()); break; }
                }
            }

            tx.Write((clrType.TypeClr, clrType.IsNullable) switch
            {
                (Helper.TypeClr.DateTime, false) => $"ConversionHelper.ParseDateTime(value!, (x => {{ obj.{property.Name} = x; return true; }}))",
                (Helper.TypeClr.DateTime, true) => $"ConversionHelper.ParseDateTimeNullable(value, (x => {{ obj.{property.Name} = x; return true; }}))",
                (Helper.TypeClr.Number, false) => $"ConversionHelper.ParseNumber<{clrType.TypeString}>(value!, (x => {{ obj.{property.Name} = x; return true; }}))",
                (Helper.TypeClr.Number, true) => $"ConversionHelper.ParseNumberNullable<{clrType.TypeString}>(value, (x => {{ obj.{property.Name} = x; return true; }}))",
                (Helper.TypeClr.String, false) => $"ConversionHelper.ParseString(value!, (x => {{ obj.{property.Name} = x; return true; }}))",
                (Helper.TypeClr.String, true) => $"ConversionHelper.ParseStringNullable(value, (x => {{ obj.{property.Name} = x; return true; }}))",
                _ => "false"
            });

            tx.WriteLine(',');
        }
    }
}